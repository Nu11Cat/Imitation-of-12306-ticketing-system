### 功能实现

### 余票查询

查询余票、购票、扣减余票是本系统的核心业务功能。

**余票查询流程与实现**：

- 生成该日车次信息时初始化redis

- 项目启动时自动初始化布隆过滤器
- 用户请求-->
- 查布隆过滤器，无效返回空，防止缓存**穿透**
- 查询缓存，命中返回
- 抢互斥锁，没抢到返回旧数据或空避免阻塞，抢到锁查数据库，防止缓存**击穿**
- 查不到数据缓存空，防止缓存**穿透**

- 查到后放入缓存，过期时间随机化，防止缓存**雪崩**

### 购票与扣减余票

**购票和扣减余票流程和实现**：

- 生成该日车次信息时初始化redis
- 用户请求-->

- **令牌桶**校验限流
- 生成初始订单
- 同步发送**MQ排队购票**，**发送确认机制**，**幂等**防止重复发送消息
- 异步购票，**Sentinel限流**，**幂等**防止重复消费，Redisson**分布式锁**串行化操作
- 循环取未处理订单，forEach执行处理方法
- 在Redis中使用**Lua脚本原子化**校验和扣减库存，出错**回滚**redis库存
- IF无选座操作，查可用车厢，循环选座
- IF有选座操作，查车厢，若选多座位，计算偏移值，任意一个偏移座位不可售，则放弃当前组
- 同步进行购票后逻辑，**Seata事务**
- 更新座位售卖情况（**乐观锁**），计算售票影响的库存区间，更改各个区间余票（**乐观锁**），同步更新订单状态
- 发送**MQ异步**调用member模块为会员添加车票

### 防止刷票/机器人

1，秒杀令牌机制防止刷票：每趟列车在每个日期生成固定数量的“购票令牌”，通过 Redis 缓存管理。用户发起购票请求时，需先抢到令牌，令牌不足或未抢到则无法继续购票，从而限制高并发抢票，防止库存超卖，同时能有效阻挡机器人或恶意刷票。

2，通过 Kaptcha 图形验证码防止脚本/机器人：在购票前需输入验证码，系统生成的验证码字符串会存入 Redis（带过期时间），用户提交时进行校验。结合令牌机制，可以增加操作门槛，防止脚本或机器人自动批量请求。

### JWT单点登录

**单点登录**指用户在一个系统登录后可以获得访问其他多个互信任系统的权限，而无需重新登录。

**主要的实现方式**：

1，共享 Session (父域 Cookie)：所有子系统使用相同的顶级域名，将 Session ID 保存在父域下。用户登录一个系统后，该 Cookie 对所有子系统可见。但是域名必须同源，不适合分布式系统。

2，CAS 模型 (中央认证服务)：用户登录操作被重定向到中央认证服务。登录成功后，中心发放一个全局票证，用户再凭此票证访问各子系统。

3，Token 模型 (如 JWT)：用户登陆后认证中心返回一个签名的 Token，用户访问时携带Token来确认用户身份。无状态，扩展性强，适合现代微服务和 API 场景。

**为什么选择JWT**：因为JWT无状态，不需要服务存储并管理“票证”的签发和状态，因为JWT本身包含所有信息，不需要服务端储存；另外不需要认证中心（涉及Token吊销或黑名单可能需要），依赖性弱，不然认证中心下线服务就都g了。

**JWT带来的问题**：Token难以主动失效，需要借助黑名单等额外的机制；另外JWT的过期时间也需要慎重，因为Token内容一旦签发无法轻易撤回。

**具体实现**：

使用Hutool提供的零依赖JWT实现(5.7.0+)；HS256（HMAC SHA-256）算法加密。

添加JwtUtil工具类，设置盐值防解密，设置token签发/过期/生效时间和内容。用户登录后resq返回token字段。

### 网关层拦截器

基于 Spring Cloud Gateway 的 `GlobalFilter`，在请求进入微服务之前统一做 登录校验（token验证、放行/拦截），作用范围是整个网关层。

**登录校验的常见方式**:

1，应用拦截器：基于MVC框架，作为业务代码的一部分，但是每个业务服务挨个加上繁琐，维护性差。

2，过滤器：更底层，功能强大但繁琐，常用于需要处理更底层逻辑时。

3，AOP：更灵活，常作为更细颗粒度的方法级权限控制的补充。

4，网关：统一认证治理，解耦，易维护。

**为什么选择网关拦截器**：网关校验是微服务架构下的最佳实践，架构解耦，性能好，方便运维。

**具体实现**：添加依赖。添加拦截器，设置不需要拦截的请求和拦截器优先级。添加@Component并实现GlobalFilter接口就会自动启动，无需配置和额外注解。

### 服务层拦截器

与网关层拦截器不同，于 Spring MVC 的 `HandlerInterceptor`，在请求已经到达具体服务后，主要做 用户上下文解析（从 token 提取用户信息并保存），方便后续业务代码使用。

**具体实现**：服务层拦截器只需要 实现 `HandlerInterceptor` 接口，再加上 `@Component`，Spring Boot 就会自动生效。

另外在各个服务添加拦截器配置类，实现WebMvcConfigurer接口，加上@Configuration，自动生效，可以为该服务配置选择拦截器。

**设计亮点**：拦截器抽取到公共模块 + 各业务模块按需配置使用 的模块化可插拔设计提高了代码复用，并且拦截器和业务模块解耦，按需启用可维护性强。

### AOP方法级日志

**为什么选择AOP实现方法级日志**：主流方式，与业务解耦无侵入，可统一管理日志策略，方便扩展。

**其他各种日志的常见实现方式**：

HTTP请求/响应日志：拦截器，过滤器 (AOP无法获取完整的HTTP请求对象)

业务流水日志：硬编码 (高度定制化，AOP难以抽象)

跨服务的调用链追踪日志：APM工具 (无侵入，在字节码层面实现，提供全局视角，性能损耗极低)

**具体实现**：添加依赖：hutool，fastjson。添加LogAspect，添加@Aspect，@Component，定义切面，设置拦截规则，排除敏感字段。

### 异常处理

统一异常处理 + 自定义异常

**统一异常处理的具体实现**：通过 `@ControllerAdvice`+ `@ExceptionHandler`集中处理所有Controller层异常，返回统一的错误响应体。包含所有异常统一处理，业务异常统一处理，校验异常统一处理。

**自定义异常处理的具体实现**：通过 自定义异常（`BusinessException`） 和 异常枚举（`BusinessExceptionEnum`），实现业务异常的标准化管理。

**优化点**：重写`fillInStackTrace()`禁用堆栈跟踪，提升性能（适用于高频业务场景）

### 线程本地变量存储会员信息

**具体实现**：创建工具类用 ThreadLocal 保存会员信息，服务层拦截器在请求进入的时候解析 token存入ThreadLocal，业务层使用工具类方法获取当前线程的会员信息。

工具类完全 依赖静态方法和静态变量 来存储和获取数据，不需要 Spring 容器管理，也不需要被注入。Spring 完全不参与这个类的生命周期。

### 异常与边界场景处理

指的是在程序中 处理可能发生错误的情况（异常）和 特殊输入或极端条件（边界场景），确保系统不会崩溃或出现不可预期行为。

**具体实现**：

1，全局异常处理：见：异常处理-统一异常处理。

2，局部异常捕获：如LoginMemberContext获取用户信息异常的捕获，JobController创建/暂停/重启/更新/删除/查看定时任务调度的异常捕获等。

3，边界场景：Validation对输入数据的边界、格式、合法性进行的检查等。

4，服务调用和外部依赖：DbUtil-getConnection的异常捕获，KaptchaController验证码生成异常的捕获等。

5，日志记录：`LOG.error` 或 `LOG.warn` 等。

...





























